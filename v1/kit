#!/usr/bin/env ruby

require 'pry'
require 'http'
require 'json'
require 'pastel'
require 'dotenv'
require 'loofah'
require 'tty-prompt'
require 'tty-command'

Dotenv.load(
  File.join(File.dirname(__FILE__), '../.env')
)

class Kit
  def start
    @args = Hash[ ARGV.flat_map { |s| s.scan(/--([^=\s]+)(?:=(\S+))?/) } ]
    @shell = TTY::Command.new
    @pastel = Pastel.new

    @shell_commands = {
      GIT_PULL: 'git pull',
      GIT_CHECKOUT_BRANCH: 'git checkout -b %s',
      GIT_CHECKOUT: 'git checkout %s',
      GIT_BRANCH_RENAME: 'git branch -m %s',
      KIT_CMD: "#{File.join(File.dirname(__FILE__), 'kit')} --command=%s --id=%s --lane=%s --quiet=1",
      KIT_ADD_CARD: "#{File.join(File.dirname(__FILE__), 'kit')} --command=add-card --id=%s --quiet=1",
    }

    @env = {
      LEANKIT_ACCOUNT_NAME: nil,
      LEANKIT_USER_EMAIL: nil,
      LEANKIT_USER_PASSWORD: nil,
      GIT_INITIALS: nil,
    }

    @definitions = {}
    @options = {}
    @cards = {}

    prepare_cards_file
    parse_options
    self
  end

  def path_to(file)
    File.join(File.dirname(__FILE__), file)
  end

  def shell(command, replacements = [])
    @shell.run(sprintf(@shell_commands[command], *replacements))
  end

  def load_from_env
    @env = @env.map do |key, val|
      [key, ENV.fetch(key.to_s, nil)]
    end.to_h
  end

  def prepare_message(message)
    sprintf "[KIT] %s", message
  end

  def log(message, color = :blue)
    puts @pastel.send(color, message)
  end

  def log_empty_line
    puts ''
  end

  def success(message = nil)
    puts @pastel.green(prepare_message(message)) unless @options[:quiet].to_i > 0
  end

  def warning(message = nil)
    puts @pastel.yellow(prepare_message(message)) unless @options[:quiet].to_i > 0
  end

  def danger(message = nil)
    puts @pastel.red(prepare_message(message)) unless @options[:quiet].to_i > 0
  end

  def add_command(cmds, callback_method)
    cmds.each do |cmd|
      @definitions[cmd] = callback_method
    end

    self
  end

  def snakecase(input, max_words = 0)
    output = input.downcase
      .gsub(/[^0-9A-Za-z ]/, '')
      .gsub(/\b(in|of|and|by|to|from|on|if|the|is)\b/, '')

    if max_words > 0
      output = output.split(' ').uniq.slice(0, max_words).join('-')
    end

    output.gsub(/ /, '-')
      .gsub(/-+/, '-').to_s
  end

  def parse_json(input)
    begin
      JSON.parse(input)
    rescue JSON::ParserError => e
      nil
    end
  end

  def prepare_cards_file
    if File.exists?(path_to('.cards'))
      @cards = parse_json(File.read(path_to('.cards')))
      @cards = @cards.map { |k, v| [k.to_sym, v] }.to_h
      return
    end

    lanes.each { |key| @cards[key] = {} }

    File.write(path_to('.cards'), @cards.to_json)
  end

  def save_cards_file
    File.write(path_to('.cards'), @cards.to_json)
  end

  def lanes
    [:dev, :rev, :fs, :acc, :mrg, :arc]
  end

  def parse_options
    options = @args.map do |key, val|
      [key.to_sym, val]
    end.to_h

    @options.merge!(options)
  end

  def authorization_header
    password = @env[:LEANKIT_USER_PASSWORD] || nil
    password = TTY::Prompt.new.mask('Your LeanKit Password?') unless password
    { user: @env[:LEANKIT_USER_EMAIL], pass: password, accountName: @env[:LEANKIT_ACCOUNT_NAME] }
  end

  def leankit_api(path = '')
    sprintf(
      'https://%s.leankit.com/%s',
      @env[:LEANKIT_ACCOUNT_NAME],
      path
    )
  end

  def leankit_get(path = '', params = {})
    parse_json(HTTP.basic_auth(authorization_header).get(leankit_api(path), form: params))
  end

  def git_initials
    @env[:GIT_INITIALS]
  end

  def cards
    @cards
  end

  def get_card_id(prefix, header)
    @cards.each do |lane_key, lane_cards|
      lane_cards.each do |lc_id, lc_props|
        if lc_props['prefix'].downcase == prefix.downcase &&
          lc_props['header'].downcase == header.downcase
          return lc_id
        end
      end
    end

    nil
  end

  def parse_card_id(id = nil)
    unless id
      danger('Please provide a card id `--id=?`')
      return
    end

    card_prefix, card_header = id.match(/([a-zA-Z]{2})([0-9]{4})/i)&.captures

    if card_prefix && card_header
      id = get_card_id(card_prefix, card_header)

      unless id
        danger("Card with header #{card_prefix}#{card_header} does not exist")
        return
      end
    end

    id
  end

  def card_exists(card_id)
    @cards.each do |_lane_key, lane_cards|
      lane_cards.each do |lc_id, _lc_props|
        return true if lc_id == card_id
      end
    end

    false
  end

  def card_lane(card_id)
    @cards.each do |lane_key, lane_cards|
      lane_cards.each do |lc_id, _lc_props|
        return lane_key if lc_id == card_id
      end
    end
  end

  def card_by_id(card_id)
    @cards.each do |_lane_key, lane_cards|
      lane_cards.each do |lc_id, card|
        return card if lc_id == card_id
      end
    end

    nil
  end

  def branch_name_of(card)
    prefix = card['customId']['prefix'].downcase
    header = card['customId']['value'].downcase
    title = snakecase(card['title'], 5)

    "#{git_initials}/#{prefix}#{header}-#{title}"
  end

  def html_to_text(input)
    Loofah.fragment(input)
      .scrub!(:escape)
      .to_text
      .gsub(/\n/, '')
  end

  def parse_card(card, exclude = false)
    parsed = {
      'id' => card['id'],
      'prefix' => card['customId']['prefix'].downcase,
      'header' => card['customId']['value'].downcase,
      'title' => card['title'],
      'description' => html_to_text(card['description']),
      'assignees' => card['assignedUsers'].map { |user| user['fullName'] }.join(', '),
    }

    parsed.merge!({
      'branch' => branch_name_of(card),
      'kit_added_at' => Time.now.strftime("%Y-%d-%m %H:%M:%S"),
      'kit_moved_at' => nil,
    }) unless exclude

    parsed
  end

  def add_card(card, lane)
    @cards[lane][card['id']] = card
  end

  def move_card(card, lane)
    origin_lane = card_lane(card['id'])

    return if lane == origin_lane

    origin_card = @cards[origin_lane][card['id']]

    origin_card[:kit_moved_at] = Time.now.strftime("%Y-%d-%m %H:%M:%S")

    @cards[lane][card['id']] = origin_card
    @cards[origin_lane].delete(card['id'].to_s)
  end

  def remove_card(card)
    origin_lane = card_lane(card['id'])
    @cards[origin_lane].delete(card['id'].to_s)
  end

  def update_card(card)
    @cards[card_lane(card['id'])][card['id']] = card
  end

  def update_card_branch(card, branch_name)
    @cards[card_lane(card['id'])][card['id']]['branch'] = branch_name
    save_cards_file
  end

  def run
    @shell = TTY::Command.new(printer: :quiet) if @options[:quiet].to_i.positive?

    warning 'Starting up'
    load_from_env
    warning "Executing Command `#{@options[:command]}`"

    if @definitions.key?(@options[:command])
      @definitions[@options[:command].to_s].call(self, @options)
    else
      @definitions['help'].call(self, @options)
    end
  end
end

Kit
  .new
  .start
  .add_command(['help', 'h', '?'], lambda { |kit, opts|
    kit.log_empty_line
    kit.log('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', :black)
    kit.log(":::::::::::::::::::: KIT ::::::::::::::::::", :green)
    kit.log('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', :black)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Branch -> kit branch|b [card-id]", :cyan)
    kit.log(" * Creates a branch from deploy without pulling the latest changes", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Branch with Pull -> kit branch-with-pull|bp [card-id]", :cyan)
    kit.log(" * Creates a branch from deploy after pulling the latest changes", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Checkout -> kit checkout|c [card-id]", :cyan)
    kit.log(" * Switches to a branch", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Find -> kit find|f [card-id]", :cyan)
    kit.log(" * Retrieves a card info", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ List -> kit list|l", :cyan)
    kit.log(" * Lists all non-archived cards", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Review -> kit review|r", :cyan)
    kit.log(" * Lists all non-archived cards with description", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Add Card -> kit add-card|ac", :cyan)
    kit.log(" * Adds a card without creating a branch", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Update Card -> kit update-card|uc", :cyan)
    kit.log(" * Updates the given cards", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Move Card -> kit move-card|mc", :cyan)
    kit.log(" * Changes the lane of the given cards", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Remove Card -> kit remove-card|rc", :cyan)
    kit.log(" * Removes the given cards", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Branch Name -> kit branch-name|bn [card-id]", :cyan)
    kit.log(" * Retrieve the branch name", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Rename Branch -> kit rename-branch|rb [card-id]", :cyan)
    kit.log(" * Sets the branch name based on card info", :green)
    kit.log_empty_line
    kit.log("ðŸ‘‰ Set Branch -> kit set-branch|sb [card-id]", :cyan)
    kit.log(" * Rename the branch for a card", :green)
    kit.log_empty_line
  })
  .add_command(['review', 'r'], lambda { |kit, opts|
    # kit --command=review

    [:mrg, :acc, :fs, :rev, :dev].each do |lane|
      kit.log('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', :black)
      kit.log(":::::::::::::::::::: #{lane.to_s.upcase} ::::::::::::::::::", :green)
      kit.log('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', :black)

      kit.cards[lane].each do |card_id, card|
        kit.log_empty_line
        kit.log("ðŸ‘‰ [#{card['prefix'].upcase}#{card['header']}] #{card['title']}", :white)
        kit.log("    ðŸŒ±  #{card['branch']}", :cyan)
        kit.log_empty_line
        kit.log("    ðŸ“–  #{card['description']}", :cyan)
        kit.log_empty_line
        kit.log("    ðŸ™‹  #{card['assignees']}", :cyan)
        kit.log("    ðŸ“Ž  LKID: #{card['id']} | ATK: #{card['kit_added_at'] || '-'} | MOK: #{card['kit_moved_at'] || '-'}", :cyan)
        kit.log("    ðŸ”—  https://icn.leankit.com/card/#{card['id']}", :cyan)
        kit.log_empty_line
      end

      kit.log_empty_line
    end
  })
  .add_command(['list', 'l'], lambda { |kit, opts|
    # kit --command=list

    [:mrg, :acc, :fs, :rev, :dev].each do |lane|
      kit.cards[lane].each do |card_id, card|
        kit.log_empty_line
        kit.log("ðŸ‘‰ [#{lane.to_s.upcase}] [#{card['prefix'].upcase}#{card['header']}] #{card['title']}", :white)
        kit.log("    ðŸŒ±  #{card['branch']}", :cyan)
        kit.log("    ðŸ™‹  #{card['assignees']}", :cyan)
        kit.log("    ðŸ“Ž  LKID: #{card['id']} | ATK: #{card['kit_added_at'] || '-'} | MOK: #{card['kit_moved_at'] || '-'}", :cyan)
        kit.log("    ðŸ”—  https://icn.leankit.com/card/#{card['id']}", :cyan)
        kit.log_empty_line
      end
    end
  })
  .add_command(['find', 'f'], lambda { |kit, opts|
    # kit --command=find
    #   --id=?

    card_id = opts[:id] || nil

    unless card_id
      kit.danger('Please provide a card id `--id=?`')
      return
    end

    card_prefix, card_header = card_id.match(/([a-zA-Z]{2})([0-9]{4})/i)&.captures

    if card_prefix && card_header
      card_id = kit.get_card_id(card_prefix, card_header)

      if !card_id
        kit.danger("Card with header #{card_prefix}#{card_header} does not exist")
        return
      end
    end

    card = kit.leankit_get("io/card/#{card_id}")

    if card
      card = kit.parse_card(card)
    else
      kit.danger("Card with ID #{card_id} not found")
      return
    end

    kit.log_empty_line
    kit.log("ðŸ‘‰ [#{card['prefix'].upcase}#{card['header']}] #{card['title']}", :white)
    kit.log("    ðŸŒ±  #{card['branch']}", :cyan)
    kit.log_empty_line
    kit.log("    ðŸ“–  #{card['description']}", :cyan)
    kit.log("    ðŸ™‹  #{card['assignees']}", :cyan)
    kit.log("    ðŸ“Ž  LKID: #{card['id']} | ATK: #{card['kit_added_at'] || '-'} | MOK: #{card['kit_moved_at'] || '-'}", :cyan)
    kit.log("    ðŸ”—  https://icn.leankit.com/card/#{card['id']}", :cyan)
    kit.log_empty_line
  })
  .add_command([
    'add-card',
    'ac',
    'move-card',
    'mc',
    'remove-card',
    'rc',
    'update-card',
    'uc',
  ], lambda { |kit, opts|
    # kit --command=card
    #   --id=?
    #   --lane=[dev, rev, acc, mrg, arc]

    card_id = opts[:id] || nil
    lane = (opts[:lane] || 'dev').to_sym

    if card_id.include? ','
      card_id.split(',').each do |id|
        clean_id = id.split.join
        kit.shell(:KIT_CMD, [opts[:command], clean_id, lane])
      end

      return
    end

    is_adding = ['add-card', 'ac'].include?(opts[:command])
    is_moving = ['move-card', 'mc'].include?(opts[:command])
    is_removing = ['remove-card', 'rc'].include?(opts[:command])
    is_updating = ['update-card', 'uc'].include?(opts[:command])

    unless card_id
      kit.danger('Please provide a card id `--id=?`')
      return
    end

    unless kit.lanes.include?(lane)
      kit.danger("Specified lane is invalid")
      return
    end

    card_prefix, card_header = card_id.match(/([a-zA-Z]{2})([0-9]{4})/i)&.captures

    if card_prefix && card_header
      card_id = kit.get_card_id(card_prefix, card_header)

      if !card_id
        kit.danger("Card with header #{card_prefix}#{card_header} does not exist")
        return
      end
    end

    if kit.card_exists(card_id) && is_adding
      kit.danger("Card with ID #{card_id} already exists")
      return
    end

    if !kit.card_exists(card_id) && (is_moving || is_removing)
      kit.danger("Card with ID #{card_id} does not exist")
      return
    end

    card = kit.leankit_get("io/card/#{card_id}")

    if card
      card = kit.parse_card(card)
    else
      kit.danger("Card with ID #{card_id} not found")
      return
    end

    kit.add_card(card, lane) if is_adding
    kit.move_card(card, lane) if is_moving
    kit.remove_card(card) if is_removing
    kit.update_card(card) if is_updating

    kit.save_cards_file

    kit.success("Card operation successful: #{opts[:command]} #{card_id} #{lane}")
  })
  .add_command(['branch-with-pull', 'bp'], lambda { |kit, opts|
    card_id = kit.parse_card_id(opts[:id] || nil)
    lane = (opts[:lane] || 'dev').to_sym

    unless card_id
      kit.danger('Please provide a card id `--id=?`')
      return
    end

    card = kit.leankit_get("io/card/#{card_id}")

    if card
      kit.shell(:GIT_CHECKOUT, @env[:DEPLOY_BRANCH])
      kit.shell(:GIT_PULL)
      kit.shell(:GIT_CHECKOUT_BRANCH, kit.branch_name_of(card))
      kit.shell(:KIT_ADD_CARD, [card_id, lane])
    end
  })
  .add_command(['branch', 'b'], lambda { |kit, opts|
    card_id = kit.parse_card_id(opts[:id] || nil)
    lane = (opts[:lane] || 'dev').to_sym

    unless card_id
      kit.danger('Please provide a card id `--id=?`')
      return
    end

    card = kit.leankit_get("io/card/#{card_id}")

    if card
      kit.shell(:GIT_CHECKOUT, @env[:DEPLOY_BRANCH])
      kit.shell(:GIT_CHECKOUT_BRANCH, kit.branch_name_of(card))
      kit.shell(:KIT_ADD_CARD, [card_id, lane])
    end
  })
  .add_command(['checkout', 'c'], lambda { |kit, opts|
    card_id = kit.parse_card_id(opts[:id] || nil)
    card = kit.card_by_id(card_id)

    if card
      kit.shell(:GIT_CHECKOUT, card['branch'])
    end
  })
  .add_command(['set-branch', 'sb'], lambda { |kit, opts|
    card_id = kit.parse_card_id(opts[:id] || nil)
    card_local = kit.card_by_id(card_id)
    card = kit.leankit_get("io/card/#{card_local['id']}")

    if card_local && card
      new_branch = kit.branch_name_of(card)
      kit.update_card_branch(card_local, new_branch)
      kit.shell(:GIT_BRANCH_RENAME, new_branch)

      kit.log_empty_line
      kit.log("ðŸŒ± [SYNC] #{kit.branch_name_of(card)}", :cyan)
      kit.log_empty_line
    end
  })
  .add_command(['branch-name', 'bn'], lambda { |kit, opts|
    card_id = kit.parse_card_id(opts[:id] || nil)
    card = kit.leankit_get("io/card/#{card_id}")
    card_local = kit.card_by_id(card_id)

    kit.log_empty_line
    kit.log("ðŸŒ± [LEANKIT] #{kit.branch_name_of(card)}", :cyan) if card
    kit.log("ðŸŒ± [LOCAL] #{card_local['branch']}", :cyan) if card_local
    kit.log_empty_line
  })
  .add_command(['rename-branch', 'rb'], lambda { |kit, opts|
    card_id = kit.parse_card_id(opts[:id] || nil)
    card = kit.leankit_get("io/card/#{card_id}")
    card_local = kit.card_by_id(card_id)

    kit.log_empty_line
    if card_local
      new_branch = (opts[:lane] || card_local['branch']).to_sym
      kit.update_card_branch(card_local, new_branch)
      kit.shell(:GIT_BRANCH_RENAME, new_branch)
      kit.log("ðŸŒ± [LOCAL] #{new_branch}", :cyan)
    elsif card
      new_branch = (opts[:lane] || card['branch']).to_sym
      kit.update_card_branch(card_local, new_branch)
      kit.shell(:GIT_BRANCH_RENAME, new_branch)
      kit.log("ðŸŒ± [LEANKIT] #{new_branch}", :cyan)
    end
    kit.log_empty_line
  })
  .run
